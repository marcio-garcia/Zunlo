# This file contains the fastlane.tools configuration
# You can find the documentation at https://docs.fastlane.tools
#
# For a list of all available actions, check out
#
#     https://docs.fastlane.tools/actions
#
# For a list of all available plugins, check out
#
#     https://docs.fastlane.tools/plugins/available-plugins
#

# Uncomment the line if you want fastlane to automatically update itself
# update_fastlane

default_platform(:ios)

platform :ios do
  # Private helper lane to configure App Store Connect API key
  private_lane :configure_api_key do
    UI.message "üîë Configuring App Store Connect API key..."

    unless ENV["APP_STORE_CONNECT_API_KEY_ID"] && ENV["APP_STORE_CONNECT_ISSUER_ID"] && ENV["APP_STORE_CONNECT_API_KEY_PATH"]
      UI.error "‚ùå API key environment variables not properly set"
      UI.error "  Required variables:"
      UI.error "    - APP_STORE_CONNECT_API_KEY_ID"
      UI.error "    - APP_STORE_CONNECT_ISSUER_ID"
      UI.error "    - APP_STORE_CONNECT_API_KEY_PATH"
      UI.user_error!("API key configuration required")
    end

    app_store_connect_api_key(
      key_id: ENV["APP_STORE_CONNECT_API_KEY_ID"],
      issuer_id: ENV["APP_STORE_CONNECT_ISSUER_ID"],
      key_filepath: ENV["APP_STORE_CONNECT_API_KEY_PATH"],
      in_house: false
    )
  end

  desc "Generate screenshots"
  lane :screenshots do
    capture_screenshots
    fix_screenshot_dimensions
  end

  desc "Fix screenshot dimensions to match App Store requirements"
  private_lane :fix_screenshot_dimensions do
    UI.message "üîß Fixing screenshot dimensions..."

    # Define correct dimensions for each device type
    # Based on https://help.apple.com/app-store-connect/#/devd274dd925
    device_dimensions = {
      "iPhone 15 Pro Max" => { width: 1290, height: 2796 },
      "iPhone 15 Pro" => { width: 1179, height: 2556 },
      "iPhone 15" => { width: 1179, height: 2556 },
      "iPhone SE (3rd generation)" => { width: 750, height: 1334 },
      "iPad Pro (12.9-inch) (6th generation)" => { width: 2048, height: 2732 }
    }

    # Sort device names by length (longest first) to avoid partial matching issues
    # e.g., "iPhone 15 Pro Max" should be checked before "iPhone 15"
    sorted_device_names = device_dimensions.keys.sort_by { |name| -name.length }

    fixed_count = 0

    ["en-US", "pt-BR"].each do |locale|
      screenshots_dir = "./screenshots/#{locale}"
      unless Dir.exist?(screenshots_dir)
        UI.message "  Skipping #{locale} (directory not found)"
        next
      end

      screenshot_files = Dir.glob("#{screenshots_dir}/*.png")
      UI.message "  Checking #{screenshot_files.count} screenshots in #{locale}..."

      screenshot_files.each do |screenshot|
        filename = File.basename(screenshot)

        # Extract device name from filename (check longest names first)
        device_name = sorted_device_names.find { |device| filename.start_with?(device) }
        unless device_name
          UI.message "  ‚ö†Ô∏è  Skipping #{filename} (no matching device)"
          next
        end

        expected = device_dimensions[device_name]

        # Get current dimensions
        current_width = `sips -g pixelWidth "#{screenshot}" | grep pixelWidth | awk '{print $2}'`.strip.to_i
        current_height = `sips -g pixelHeight "#{screenshot}" | grep pixelHeight | awk '{print $2}'`.strip.to_i

        # Resize if dimensions don't match
        if current_width != expected[:width] || current_height != expected[:height]
          UI.message "  üìê Resizing #{filename}: #{current_width}x#{current_height} ‚Üí #{expected[:width]}x#{expected[:height]}"
          system("sips", "-z", expected[:height].to_s, expected[:width].to_s, screenshot, out: "/dev/null", err: "/dev/null")
          fixed_count += 1
        else
          UI.verbose "  ‚úì #{filename}: #{current_width}x#{current_height} (correct)"
        end
      end
    end

    if fixed_count > 0
      UI.success "‚úÖ Fixed #{fixed_count} screenshot(s)!"
    else
      UI.success "‚úÖ All screenshots already have correct dimensions!"
    end
  end

  desc "Run tests"
  lane :test do
    run_tests(
      scheme: "Zunlo - debug",
      devices: ["iPhone 15 Pro (17.4)"]
    )
  end

  desc "Run tests on all devices"
  lane :test_all_devices do
    run_tests(
      scheme: "Zunlo - debug",
      devices: [
        "iPhone 15 Pro (17.4)",
        "iPhone 15 Pro Max (17.4)",
        "iPhone 15 (17.4)",
        "iPhone SE (3rd generation) (17.4)",
        "iPad Pro (12.9-inch) (6th generation) (17.4)"
      ]
    )
  end

  desc "Build for testing"
  lane :build_for_testing do
    build_app(
      scheme: "Zunlo - debug",
      configuration: "Debug",
      build_for_testing: true
    )
  end

  desc "Generate screenshots and upload to App Store Connect"
  lane :screenshots_and_upload do
    capture_screenshots
    fix_screenshot_dimensions
    deliver(
      api_key: configure_api_key,
      skip_binary_upload: true,
      skip_metadata: true,
      force: true,
      run_precheck_before_submit: false
    )
  end

  desc "Upload metadata to App Store Connect"
  lane :upload_metadata do
    deliver(
      api_key: configure_api_key,
      skip_binary_upload: true,
      skip_screenshots: true,
      force: true,
      run_precheck_before_submit: false
    )
  end

  desc "Fix existing screenshot dimensions"
  lane :fix_screenshots do
    fix_screenshot_dimensions
  end

  desc "Upload screenshots to App Store Connect"
  lane :upload_screenshots do
    fix_screenshot_dimensions

    # Debug: Print what screenshots we're about to upload
    UI.message "üì∏ Screenshots to upload:"
    ["en-US", "pt-BR"].each do |locale|
      screenshots_dir = "./screenshots/#{locale}"
      if Dir.exist?(screenshots_dir)
        screenshots = Dir.glob("#{screenshots_dir}/*.png")
        UI.message "  #{locale}: #{screenshots.count} files"
        screenshots.first(3).each { |s| UI.message "    - #{File.basename(s)}" }
      end
    end

    deliver(
      api_key: configure_api_key,
      skip_binary_upload: true,
      skip_metadata: true,
      force: true,
      run_precheck_before_submit: false,
      overwrite_screenshots: true
    )
  end

  desc "Validate metadata locally"
  lane :validate_metadata do
    UI.message "üîç Validating metadata files..."

    # Check required files exist
    required_files = {
      "en-US" => ["name.txt", "subtitle.txt", "description.txt", "keywords.txt", "release_notes.txt"],
      "pt-BR" => ["name.txt", "subtitle.txt", "description.txt", "keywords.txt", "release_notes.txt"]
    }

    required_files.each do |locale, files|
      files.each do |file|
        path = "metadata/#{locale}/#{file}"
        unless File.exist?(path)
          UI.user_error!("‚ùå Missing required file: #{path}")
        end

        content = File.read(path).strip
        if content.empty?
          UI.user_error!("‚ùå Empty file: #{path}")
        end

        # Check description length (max 4000 characters)
        if file == "description.txt" && content.length > 4000
          UI.user_error!("‚ùå Description too long in #{locale}: #{content.length}/4000 characters")
        end

        # Check subtitle length (max 30 characters)
        if file == "subtitle.txt" && content.length > 30
          UI.user_error!("‚ùå Subtitle too long in #{locale}: #{content.length}/30 characters")
        end

        # Check keywords (max 100 characters)
        if file == "keywords.txt" && content.length > 100
          UI.user_error!("‚ùå Keywords too long in #{locale}: #{content.length}/100 characters")
        end
      end
    end

    UI.success "‚úÖ All metadata files validated successfully!"
  end

  desc "Preview metadata without uploading"
  lane :preview_metadata do
    validate_metadata
    UI.message "üìã App Configuration Preview:"
    UI.message "   Bundle ID: #{ENV['APP_BUNDLE_ID'] || 'net.loginode.zunloapp'}"
    UI.message "   Apple ID: marcio@loginode.net"
    UI.message ""
    UI.success "‚úÖ Metadata is valid and ready for upload!"
    UI.message "üí° To upload to App Store Connect, run: fastlane upload_metadata"
  end

  desc "Verify metadata with App Store Connect (requires authentication)"
  lane :verify_metadata_remote do
    validate_metadata
    deliver(
      api_key: configure_api_key,
      skip_binary_upload: true,
      skip_screenshots: true,
      run_precheck_before_submit: false,
      submit_for_review: false
    )
  end

  desc "Complete App Store preparation (screenshots + metadata)"
  lane :prepare_app_store do
    validate_metadata
    capture_screenshots
    fix_screenshot_dimensions
    deliver(
      api_key: configure_api_key,
      skip_binary_upload: true,
      force: true,
      run_precheck_before_submit: false
    )
  end

  # Environment-specific lanes
  desc "Upload metadata for production"
  lane :upload_metadata_prod do
    ENV["APP_BUNDLE_ID"] = "net.loginode.zunloapp"
    upload_metadata
  end

  desc "Upload metadata for staging"
  lane :upload_metadata_staging do
    ENV["APP_BUNDLE_ID"] = "net.loginode.zunloapp.stg"
    upload_metadata
  end

  desc "Upload metadata for development"
  lane :upload_metadata_dev do
    ENV["APP_BUNDLE_ID"] = "net.loginode.zunloapp.dev"
    upload_metadata
  end

  desc "Generate screenshots for specific environment"
  lane :screenshots_env do |options|
    bundle_id = options[:bundle_id]
    if bundle_id
      ENV["APP_BUNDLE_ID"] = bundle_id
      UI.message "üì± Using bundle ID: #{bundle_id}"
    end
    capture_screenshots
  end

  # MARK: - Code Signing

  desc "Setup Match - Generate certificates and provisioning profiles"
  lane :setup_match do
    UI.message "üîê Setting up Match code signing..."

    # Get API key first (while env vars are still set)
    api_key = configure_api_key

    # Temporarily clear env var to avoid conflict with api_key parameter
    saved_key_path = ENV.delete("APP_STORE_CONNECT_API_KEY_PATH")

    match(
      type: "appstore",
      readonly: false,
      app_identifier: "net.loginode.zunloapp",
      api_key: api_key
    )

    # Restore environment variable
    ENV["APP_STORE_CONNECT_API_KEY_PATH"] = saved_key_path

    UI.success "‚úÖ Certificates and provisioning profiles installed!"
    UI.message "üí° Next: Disable automatic signing in Xcode"
    UI.message "   1. Open Zunlo.xcodeproj"
    UI.message "   2. Select 'Zunlo' target ‚Üí Signing & Capabilities"
    UI.message "   3. Uncheck 'Automatically manage signing'"
    UI.message "   4. Select provisioning profile: match AppStore net.loginode.zunloapp"
  end

  # MARK: - TestFlight / App Store

  desc "Build and upload to TestFlight"
  lane :beta do
    # Ensure we're using production configuration
    ENV["APP_BUNDLE_ID"] = "net.loginode.zunloapp"

    UI.message "üöÄ Building for TestFlight..."
    UI.message "   Scheme: Zunlo"
    UI.message "   Bundle ID: #{ENV['APP_BUNDLE_ID']}"

    # Increment build number
    increment_build_number(
      xcodeproj: "Zunlo.xcodeproj"
    )

    # Get code signing from Match
    api_key = configure_api_key
    saved_key_path = ENV.delete("APP_STORE_CONNECT_API_KEY_PATH")
    match(
      type: "appstore",
      readonly: true,
      app_identifier: "net.loginode.zunloapp",
      api_key: api_key
    )
    ENV["APP_STORE_CONNECT_API_KEY_PATH"] = saved_key_path

    # Build the app
    build_app(
      scheme: "Zunlo",
      export_method: "app-store",
      configuration: "Release",
      clean: true,
      output_directory: "./build",
      output_name: "Zunlo.ipa"
    )

    # Upload to TestFlight
    upload_to_testflight(
      api_key: configure_api_key,
      skip_waiting_for_build_processing: true,
      distribute_external: false,
      notify_external_testers: false
    )

    UI.success "‚úÖ Successfully uploaded to TestFlight!"
    UI.message "üí° Build will be available for testing once processing completes"
  end

  desc "Build and upload to TestFlight with external testing"
  lane :beta_external do
    # Ensure we're using production configuration
    ENV["APP_BUNDLE_ID"] = "net.loginode.zunloapp"

    UI.message "üöÄ Building for TestFlight (External Testing)..."

    # Increment build number
    increment_build_number(
      xcodeproj: "Zunlo.xcodeproj"
    )

    # Get code signing from Match
    api_key = configure_api_key
    saved_key_path = ENV.delete("APP_STORE_CONNECT_API_KEY_PATH")
    match(
      type: "appstore",
      readonly: true,
      app_identifier: "net.loginode.zunloapp",
      api_key: api_key
    )
    ENV["APP_STORE_CONNECT_API_KEY_PATH"] = saved_key_path

    # Build the app
    build_app(
      scheme: "Zunlo",
      export_method: "app-store",
      configuration: "Release",
      clean: true,
      output_directory: "./build",
      output_name: "Zunlo.ipa"
    )

    # Upload to TestFlight with external distribution
    upload_to_testflight(
      api_key: configure_api_key,
      skip_waiting_for_build_processing: false,
      distribute_external: true,
      notify_external_testers: true,
      changelog: "Bug fixes and improvements"
    )

    UI.success "‚úÖ Successfully uploaded to TestFlight!"
    UI.message "üìß External testers will be notified once build is approved"
  end

  desc "Build for App Store submission"
  lane :release do
    # Ensure we're using production configuration
    ENV["APP_BUNDLE_ID"] = "net.loginode.zunloapp"

    UI.message "üì¶ Building for App Store release..."

    # Validate metadata first
    validate_metadata

    # Increment build number
    increment_build_number(
      xcodeproj: "Zunlo.xcodeproj"
    )

    # Get code signing from Match
    api_key = configure_api_key
    saved_key_path = ENV.delete("APP_STORE_CONNECT_API_KEY_PATH")
    match(
      type: "appstore",
      readonly: true,
      app_identifier: "net.loginode.zunloapp",
      api_key: api_key
    )
    ENV["APP_STORE_CONNECT_API_KEY_PATH"] = saved_key_path

    # Build the app
    build_app(
      scheme: "Zunlo",
      export_method: "app-store",
      configuration: "Release",
      clean: true,
      output_directory: "./build",
      output_name: "Zunlo.ipa"
    )

    # Upload to App Store Connect
    deliver(
      api_key: configure_api_key,
      skip_metadata: false,
      skip_screenshots: false,
      force: true,
      run_precheck_before_submit: false,
      submit_for_review: false,
      automatic_release: false
    )

    UI.success "‚úÖ Successfully uploaded to App Store Connect!"
    UI.message "üí° Review your build in App Store Connect before submitting for review"
  end
end
